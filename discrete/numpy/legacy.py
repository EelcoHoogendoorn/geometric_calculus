"""
This module contains pure numpy implementations of the discrete geometric derivative leapfrog scheme
While less generic and efficient than the autogenerated and compiled code available in sister modules,
for the sake of mentally tracing your steps through the code,
and experimenting with questions like 'why wouldnt there be an extra square or minus here',
this format is hard to beat.
"""


import numpy as np

def ed(a, d):
	"""first order exterior derivative with periodic bcs"""
	return np.diff(a, axis=d, append=np.take(a, [0], axis=d))
def id(a, d):
	"""first order interior derivative with periodic bcs"""
	return np.diff(a, axis=d, prepend=np.take(a, [-1], axis=d))

# FIXME: make this dim-dependent!
speed = 0.5
def edt(lhs, rhs):
	lhs -= rhs * speed
def edx(a):
	return ed(a, 0)
def edy(a):
	return ed(a, 1)
def edz(a):
	return ed(a, 2)

metric = 'spacelike'
if metric == 'spacelike':

	def idt(lhs, rhs):
		lhs -= rhs * speed
	def idx(a):
		return id(a, 0)
	def idy(a):
		return id(a, 1)
	def idz(a):
		return id(a, 2)
if metric == 'timelike':
	def idt(lhs, rhs):
		lhs += rhs * speed
	def idx(a):
		return -id(a, 0)
	def idy(a):
		return -id(a, 1)
	def idz(a):
		return -id(a, 2)


class Field:
	def __init__(self, shape, components):
		self.shape = shape
		self.ndim = len(shape)
		self.dtype = np.float32
		self.arr = np.zeros((components,) + shape, dtype=self.dtype)

	def meshgrid(self):
		xs = [np.linspace(-1, 1, s, endpoint=False) for s in self.shape]
		return np.array(np.meshgrid(*xs, indexing='ij'))
	# def meshgrid_c(self):
	# 	"""component-specific meshgrid"""
	# 	xs = [np.linspace(-1, 1, s, endpoint=False) for s in self.shape]
	# 	from discrete.util import deltas
	# 	deltas()
	# 	return np.array(np.meshgrid(*xs, indexing='ij'))

	def gaussian(self, sigma):
		x = self.meshgrid()
		return np.exp(-(x ** 2 / sigma ** 2).sum(0))


class BivectorField3(Field):
	def __init__(self, shape):
		assert len(shape) == 2
		super(BivectorField3, self).__init__(shape, 3)

	def step(self):
		xy, xt, yt = self.arr
		# temporal update
		idt(xt, -idy(xy))
		idt(yt,  idx(xy))
		# spatial update
		edt(xy, -edy(xt) + edx(yt))


class BivectorField4(Field):
	def __init__(self, shape):
		assert len(shape) == 3
		super(BivectorField4, self).__init__(shape, 6)

	def step(self):
		xy, yz, zx, xt, yt, zt = self.arr
		# temporal update
		idt(xt, idz(zx) - idy(xy))
		idt(yt, idx(xy) - idz(yz))
		idt(zt, idy(yz) - idx(zx))
		# spatial update
		edt(xy, -edy(xt) + edx(yt))
		edt(yz, -edz(yt) + edy(zt))
		edt(zx, -edx(zt) + edz(xt))

	def step_mass(self):
		xy, yz, zx, xt, yt, zt = self.arr
		m = .1
		# temporal update
		idt(xt, idz(zx) - idy(xy)   - m * yz)
		idt(yt, idx(xy) - idz(yz)   - m * zx)
		idt(zt, idy(yz) - idx(zx)   - m * xy)
		# spatial update
		edt(xy, -edy(xt) + edx(yt)  + m * zt)
		edt(yz, -edz(yt) + edy(zt)  + m * xt)
		edt(zx, -edx(zt) + edz(xt)  + m * yt)


class RotorField3(Field):
	def __init__(self, shape):
		assert len(shape) == 2
		super(RotorField3, self).__init__(shape, 4)
		self.arr[0] = 1

	def step(self):
		s, xy, xt, yt = self.arr
		# temporal update
		idt(xt, -idy(xy) + edx(s))
		idt(yt,  idx(xy) + edy(s))
		# spatial update
		edt(xy, -edy(xt) + edx(yt))
		edt(s,  +idx(xt) + idy(yt))


class RotorField4(Field):
	def __init__(self, shape):
		assert len(shape) == 3
		super(RotorField4, self).__init__(shape, 8)
		self.arr[0] = 1

	def step(self):
		s, xy, yz, zx, xt, yt, zt, xyzt = self.arr
		# temporal update
		idt(xyzt, edz(xy) + edx(yz) + edy(zx))      # xyz eq
		idt(xt,   idz(zx) - idy(xy) + edx(s))
		idt(yt,   idx(xy) - idz(yz) + edy(s))
		idt(zt,   idy(yz) - idx(zx) + edz(s))
		# spatial update
		edt(xy,  -edy(xt) + edx(yt) + idz(xyzt))    # xyt eq
		edt(yz,  -edz(yt) + edy(zt) + idx(xyzt))
		edt(zx,  -edx(zt) + edz(xt) + idy(xyzt))
		edt(s,   +idx(xt) + idy(yt) + idz(zt))

	def step_mass(self):
		s, xy, yz, zx, xt, yt, zt, xyzt = self.arr
		# construct geometric product operator
		# FIXME: this is dual-style mass term. is missing an interpolation operation!
		# mass_term = self.arr * xyz
		m = .1
		# temporal update
		idt(xyzt, edz(xy) + edx(yz) + edy(zx)   + m * s)
		idt(xt, idz(zx) - idy(xy) + edx(s)      - m * yz)
		idt(yt, idx(xy) - idz(yz) + edy(s)      - m * zx)
		idt(zt, idy(yz) - idx(zx) + edz(s)      - m * xy)
		# spatial update
		edt(xy, -edy(xt) + edx(yt) + idz(xyzt)  + m * zt)
		edt(yz, -edz(yt) + edy(zt) + idx(xyzt)  + m * xt)
		edt(zx, -edx(zt) + edz(xt) + idy(xyzt)  + m * yt)
		edt(s, +idx(xt) + idy(yt) + idz(zt)     - m * xyzt)

	def step_23(self):
		# FIXME: exploration of step with dz nuked out
		#  equations decouple into two independent parts
		#  one of which is identical to even-grade in 2+1
		#  however, if adding a dualizing mass term, they will couple again
		#  does seem like this is the best way to look at it
		s, xy, yz, zx, xt, yt, zt, xyzt = self.arr
		# temporal update
		idt(xyzt,  + edx(yz) + edy(zx))
		idt(zt,   idy(yz) - idx(zx))
		# spatial update
		edt(yz,  + edy(zt) + idx(xyzt))
		edt(zx,  -edx(zt) + idy(xyzt))

		# temporal update
		idt(xt,   - idy(xy) + edx(s))
		idt(yt,   idx(xy) + edy(s))

		# spatial update
		edt(xy,  -edy(xt) + edx(yt))
		edt(s,   +idx(xt) + idy(yt))


class OddField4(Field):
	def __init__(self, shape):
		assert len(shape) == 3
		super(OddField4, self).__init__(shape, 8)

	def step(self):
		x, y, z, t, xyt, xzt, yzt, xyz = self.arr

		idt(t, + idx(x) + idy(y) + idz(z))
		idt(xyt, + edx(y) - edy(x) + idz(xyz))
		idt(xzt, + edx(z) - idy(xyz) - edz(x))
		idt(yzt, + idx(xyz) + edy(z) - edz(y))

		edt(x, + edx(t) - idy(xyt) - idz(xzt))
		edt(y, + idx(xyt) + edy(t) - idz(yzt))
		edt(z, + idx(xzt) + idy(yzt) + edz(t))
		edt(xyz, + edx(yzt) - edy(xzt) + edz(xyt))


class MultiVectorField4(Field):
	def __init__(self, shape):
		assert len(shape) == 3
		super(MultiVectorField4, self).__init__(shape, 16)

	def step_mass(self, m=1):
		s, x, y, z, t, xy, xz, yz, xt, yt, zt, xyz, xyt, xzt, yzt, xyzt = self.arr
		edt(s,    m*t    +idx(xt)+idy(yt)+idz(zt))
		edt(x,    m*xt   +edx(t)-idy(xyt)-idz(xzt))
		edt(y,    m*yt   +idx(xyt)+edy(t)-idz(yzt))
		edt(z,    m*zt   +idx(xzt)+idy(yzt)+edz(t))
		edt(xy,   m*xyt  +edx(yt)-edy(xt)+idz(xyzt))
		edt(xz,   m*xzt  +edx(zt)-idy(xyzt)-edz(xt))
		edt(yz,   m*yzt  +idx(xyzt)+edy(zt)-edz(yt))
		edt(xyz,  m*xyzt +edx(yzt)-edy(xzt)+edz(xyt))

		idt(t,    -m*s    +idx(x)+idy(y)+idz(z))
		idt(xt,   -m*x    +edx(s)-idy(xy)-idz(xz))
		idt(yt,   -m*y    +idx(xy)+edy(s)-idz(yz))
		idt(zt,   -m*z    +idx(xz)+idy(yz)+edz(s))
		idt(xyt,  -m*xy   +edx(y)-edy(x)+idz(xyz))
		idt(xzt,  -m*xz   +edx(z)-idy(xyz)-edz(x))
		idt(yzt,  -m*yz   +idx(xyz)+edy(z)-edz(y))
		idt(xyzt, -m*xyz  +edx(yz)-edy(xz)+edz(xy))


class MultiVectorField3(Field):
	def __init__(self, shape):
		assert len(shape) == 2
		super(MultiVectorField3, self).__init__(shape, 8)

	def step_mass(self, m=5e-1, q=1e-1):
		s, x, y, t, xy, xt, yt, xyt = self.arr

		edt(s,    m*t    +idx(xt)+idy(yt))
		edt(x,    m*xt   +edx(t)-idy(xyt))
		edt(y,    m*yt   +idx(xyt)+edy(t))
		edt(xy,   m*xyt  +edx(yt)-edy(xt))

		idt(t,    -m*s    +idx(x)+idy(y))
		idt(xt,   -m*x    +edx(s)-idy(xy))
		idt(yt,   -m*y    +idx(xy)+edy(s))
		idt(xyt,  -m*xy   +edx(y)-edy(x))

	def step_mass_q(self, m=5e-1, q=1e-1):
		s, x, y, t, xy, xt, yt, xyt = self.arr
		# FIXME: do not fully trust these!
		# is_multivector: 1, x, y, t, xy, xt, yt, xyt
		# ╬════╬════╬════╬════╬════╬════╬════╬════╬════╬
		# ║ ++-║ 000║ 100║ 010║ 001║ 110║ 101║ 011║ 111║
		# ╬════╬════╬════╬════╬════╬════╬════╬════╬════╬
		# ║    ║+111│+011│-101│-110│+001│+010│-100│-000║
		# ╬════╬════╬════╬════╬════╬════╬════╬════╬════╬

		edt(s,    m*t    +q*t*xyt   +idx(xt)+idy(yt))
		edt(x,    m*xt   +q*xt*yt   +edx(t)-idy(xyt))
		edt(y,    m*yt   -q*yt*xt   +idx(xyt)+edy(t))
		edt(xy,   m*xyt  -q*xyt*t   +edx(yt)-edy(xt))

		idt(t,    -m*s   +q*s*xy    +idx(x)+idy(y))
		idt(xt,   -m*x   +q*x*y     +edx(s)-idy(xy))
		idt(yt,   -m*y   -q*y*x     +idx(xy)+edy(s))
		idt(xyt,  -m*xy  -q*xy*s    +edx(y)-edy(x))



class MultiVectorField2(Field):
	def __init__(self, shape):
		assert len(shape) == 1
		super(MultiVectorField2, self).__init__(shape, 4)

	def step_mass(self, m=1, q=0):
		s, x, t, xt = self.arr
		# q = +5e-1
		# edt(s,    m*t*(1+xt*q)    +idx(xt))
		# edt(x,    m*xt*(1+t*q)   +edx(t))
		#
		# idt(t,    -m*s*(1-x*q)    +idx(x))
		# idt(xt,   -m*x*(1-s*q)    +edx(s))

		# q = -2.5e-1
		# edt(s,    m*t*(1-t*q)    +idx(xt))
		# edt(x,    m*xt*(1-xt*q)   +edx(t))
		#
		# idt(t,    -m*s*(1-s*q)    +idx(x))
		# idt(xt,   -m*x*(1-x*q)    +edx(s))
		# cubed model; quite stable but also a tad boring
		# q = 2.5e-1
		# edt(s,    m*t*(1-t**2*q)    +idx(xt))
		# edt(x,    m*xt*(1-xt**2*q)   +edx(t))
		#
		# idt(t,    -m*s*(1-s*s*q)    +idx(x))
		# idt(xt,   -m*x*(1-x*x*q)    +edx(s))
		# directional derivative
		# q = -2.5e-1
		# edt(s,    m*t*(1-s*q)    +idx(xt))
		# # FIXME: should xt*x recieve a minus?
		# edt(x,    m*xt*(1-x*q)   +edx(t))
		#
		# idt(t,    -m*s*(1-t*q)    +idx(x))
		# idt(xt,   -m*x*(1-xt*q)    +edx(s))

		# q = -1e-1
		# edt(s,    m*t + t*s*q    +idx(xt))
		# edt(x,    m*xt + xt*x*q   +edx(t))
		#
		# idt(t,    -m*s + s*t*q    +idx(x))
		# idt(xt,   -m*x + x*xt*q    +edx(s))

		# prod of leapfrog and dual as nonlinear term?
		# q = 1e-1
		edt(s,    m*t + t*xt*q    +idx(xt))
		edt(x,    m*xt + xt*t*q   +edx(t))

		idt(t,    -m*s - s*x*q    +idx(x))
		idt(xt,   -m*x - x*s*q    +edx(s))

		# # burgers-style nonlinearity
		# edt(s, m * t + (1+ t*q) * +idx(xt))
		# edt(x, m * xt + (1+ xt*q) * +edx(t))
		#
		# idt(t, -m * s - (1+ s*q) * +idx(x))
		# idt(xt, -m * x - (1+ x*q) * +edx(s))


class DualMultiVectorField2(Field):
	def __init__(self, shape):
		assert len(shape) == 1
		super(DualMultiVectorField2, self).__init__(shape, 4)
		self.arr = np.zeros((2, 4,) + shape, dtype=self.dtype)

	def step_mass(self, m=1, c=1):
		(p, px, pt, pxt), (d, dx, dt, dxt) = self.arr

		# (p, px, pt, pxt) * xt = pxt,  pt,  px, pxt
		# xt * (d, dx, dt, dxt) = dxt, -dt, -dx, pxt
		# update primal vars
		edt(p,    +m*pt   +idx(pxt)  +c*dx)
		edt(px,   +m*pxt  +edx(pt)   +c*d)
		# update dual vars
		idt(dt,   -m*d    +idx(dx)   -c*pxt)
		idt(dxt,  -m*dx   +edx(d)    -c*pt)

		# update primal vars
		idt(pt,   -m*p    +idx(px)   +c*dxt)
		idt(pxt,  -m*px   +edx(p)    +c*dt)
		# update dual vars
		edt(d,    +m*dt   +idx(dxt)  -c*px)
		edt(dx,   +m*dxt  +edx(dt)   -c*p)

	def step_mass_q(self, m=(0, 1), c=1):
		(p, px, pt, pxt), (d, dx, dt, dxt) = self.arr
		mp, md = m
		# FIXME: make first order coupling also more configurable?
		# (p, px, pt, pxt) * xt = pxt,  pt,  px, pxt
		# xt * (d, dx, dt, dxt) = dxt, -dt, -dx, pxt
		# update primal vars
		qc = d*pxt, dx*pt    # quadratic cross terms in this half-step
		edt(p,    +mp*pt   +idx(pxt)  +c*dx)
		edt(px,   +mp*pxt  +edx(pt)   +c*d)
		# update dual vars
		idt(dt,   -md*d    +idx(dx)   -c*pxt)
		idt(dxt,  -md*dx   +edx(d)    -c*pt)

		qc = p*dxt, px*dt
		# update primal vars
		idt(pt,   -mp*p    +idx(px)   +c*dxt)
		idt(pxt,  -mp*px   +edx(p)    +c*dt)
		# update dual vars
		edt(d,    +md*dt   +idx(dxt)  -c*px)
		edt(dx,   +md*dxt  +edx(dt)   -c*p)


class DualMultiVectorField3(Field):
	def __init__(self, shape):
		assert len(shape) == 2
		super(DualMultiVectorField3, self).__init__(shape, 8)
		self.arr = np.zeros((2, 8,) + shape, dtype=self.dtype)

	def step_mass(self, m=1e-1, c=1e-1):
		(p, px, py, pt, pxy, pxt, pyt, pxyt), \
		(d, dx, dy, dt, dxy, dxt, dyt, dxyt) = self.arr

		edt(p,    +m*pt    +c*dxy   +idx(pxt)+idy(pyt))
		edt(px,   +m*pxt   +c*dy    +edx(pt)-idy(pxyt))
		edt(py,   +m*pyt   +c*dx    +idx(pxyt)+edy(pt))
		edt(pxy,  +m*pxyt  +c*d     +edx(pyt)-edy(pxt))

		idt(dt,   -m*d     +c*pxyt  +idx(dx)+idy(dy))
		idt(dxt,  -m*dx    +c*pyt   +edx(d)-idy(dxy))
		idt(dyt,  -m*dy    +c*pxt   +idx(dxy)+edy(d))
		idt(dxyt, -m*dxy   +c*pt    +edx(dy)-edy(dx))

		edt(d,    +m*dt    -c*pxy   +idx(dxt)+idy(dyt))
		edt(dx,   +m*dxt   -c*py    +edx(dt)-idy(dxyt))
		edt(dy,   +m*dyt   -c*px    +idx(dxyt)+edy(dt))
		edt(dxy,  +m*dxyt  -c*p     +edx(dyt)-edy(dxt))

		idt(pt,   -m*p     -c*dxyt  +idx(px)+idy(py))
		idt(pxt,  -m*px    -c*dyt   +edx(p)-idy(pxy))
		idt(pyt,  -m*py    -c*dxt   +idx(pxy)+edy(p))
		idt(pxyt, -m*pxy   -c*dt    +edx(py)-edy(px))


class MultiMultiVectorField2(Field):
	"""n-component multivector field"""
	def __init__(self, shape, n):
		assert len(shape) == 1
		super(MultiMultiVectorField2, self).__init__(shape, 4)
		self.arr = np.zeros((4, n) + shape, dtype=self.dtype)
		self.c = np.zeros((n,))             # courant number/ prob want to keep this a single constant!
		self.M = np.zeros((n, n))           # mass/mixing matrix
		self.Mt = np.zeros((n, n))          # mass/mixing matrix
		self.Mx = np.zeros((n, n))          # mass/mixing matrix
		self.Q = np.zeros((n, n, n))        # nonlinear terms
		# self.m[0, 0] = 1    # the massive field
		# self.Q[0, 0, 1] = .5
		# self.Q[1, 1, 0] = .5

	def step_mass_q(self, V=0):
		s, x, t, xt = self.arr
		# idx = lambda x: id(x, 1)
		# edx = lambda x: ed(x, 1)
		def edt(lhs, rhs):
			lhs += rhs * speed
		def idt(lhs, rhs):
			lhs += rhs * speed
		ed = lambda x, a: np.roll(x, -1, a) - x
		id = lambda x, a: x - np.roll(x, +1, a)
		idx = lambda x: id(x, 1)
		edx = lambda x: ed(x, 1)

		def cubic(v):
			return 0
			# FIXME: inner prod here has sign implications?
			# qv = np.einsum('n..., m...->nm...', v, v)
			# return np.einsum('nm..., nmo->o...', qv, Q)
			return np.einsum('nmo..., n..., m..., o...->o...', self.Q, v, v, v)
		def mass(v):
			# return 0
			# return self.m.dot(v) + V*v
			return np.einsum('nm...,n...->m...', self.M, v)
		def mass_t(v):
			return 0
			return np.einsum('nm...,n...->m...', self.Mt, v)

		def mass_x(v):
			# FIXME: this terms involves dualiation and multiply by t
			#  it needs interpolation
			return 0
			return np.einsum('nm...,n...->m...', self.Mx, v)

		# return self.mt.dot(v)

		edt(s,    +idx(xt)   +mass(t)  -mass_t(s)  +mass_x(xt)  -cubic(t))   #-cubic for inner of t
		edt(x,    -edx(t)    -mass(xt) +mass_t(x)  +mass_x(t)  -cubic(xt))

		idt(t,    -idx(x)    -mass(s)  +mass_t(t)  -mass_x(x)  -cubic(s))
		idt(xt,   +edx(s)    +mass(x)  -mass_t(xt) -mass_x(s)  +cubic(x))


class MultiMultiVectorField4(Field):
	"""n-component multivector field"""
	def __init__(self, shape, n):
		assert len(shape) == 3
		c = 2**4
		super(MultiMultiVectorField4, self).__init__(shape, c)
		self.arr = np.zeros((c, n) + shape, dtype=self.dtype)
		self.c = np.zeros((n,))             # courant number/ prob want to keep this a single constant!
		self.M = np.zeros((n, n))           # mass/mixing matrix
		self.Mx = np.zeros((n, n))           # mass/mixing matrix
		self.c[...] = speed

	def step(self, V):

		def edt(lhs, rhs):
			lhs += rhs * speed
		def idt(lhs, rhs):
			lhs += rhs * speed
		ed = lambda x, a: np.roll(x, -1, a) - x
		id = lambda x, a: x - np.roll(x, +1, a)
		idx = lambda x: id(x, 1)
		edx = lambda x: ed(x, 1)
		idy = lambda x: id(x, 2)
		edy = lambda x: ed(x, 2)
		idz = lambda x: id(x, 3)
		edz = lambda x: ed(x, 3)
		def mass(v):
			return np.einsum('nm...,n...->m...', self.M, v) + V * v
		def mass_x(v):
			"""xyz dualized mass term"""
			return np.einsum('nm...,n...->m...', self.Mx, v) + V * v

		s, x, y, z, t, xy, xz, yz, xt, yt, zt, xyz, xyt, xzt, yzt, xyzt = self.arr
		edt(s, +idx(xt)+idy(yt)+idz(zt)      +mass(t)       - mass_x(xyzt))	    # t
		edt(xy, +edx(yt)-edy(xt)+idz(xyzt) 	 +mass(xyt)     + mass_x(zt))    # xyt
		edt(xz, +edx(zt)-idy(xyzt)-edz(xt) 	 +mass(xzt)     - mass_x(yt))    # xzt
		edt(yz, +idx(xyzt)+edy(zt)-edz(yt) 	 +mass(yzt)     + mass_x(xt))    # yzt
		edt(x, -edx(t)+idy(xyt)+idz(xzt) 	 -mass(xt)      + mass_x(yzt))     # xt
		edt(y, -idx(xyt)-edy(t)+idz(yzt) 	 -mass(yt)      - mass_x(xzt))     # yt
		edt(z, -idx(xzt)-idy(yzt)-edz(t) 	 -mass(zt)      + mass_x(xyt))     # zt
		edt(xyz, -edx(yzt)+edy(xzt)-edz(xyt) -mass(xyzt)    - mass_x(t))	# xyzt

		idt(xt, +edx(s)-idy(xy)-idz(xz)      +mass(x)       - mass_x(yz))	    # x
		idt(yt, +idx(xy)+edy(s)-idz(yz)      +mass(y)       + mass_x(xz))	    # y
		idt(zt, +idx(xz)+idy(yz)+edz(s)      +mass(z)       - mass_x(xy))	    # z
		idt(xyzt, +edx(yz)-edy(xz)+edz(xy)   +mass(xyz)     + mass_x(s))	# xyz
		idt(t, -idx(x)-idy(y)-idz(z)         -mass(s)       + mass_x(xyz))	    # s
		idt(xyt, -edx(y)+edy(x)-idz(xyz)     -mass(xy)      - mass_x(z))	    # xy
		idt(xzt, -edx(z)+idy(xyz)+edz(x)     -mass(xz)      + mass_x(y))	    # xz
		idt(yzt, -idx(xyz)-edy(z)+edz(y)     -mass(yz)      - mass_x(x))	    # yz
